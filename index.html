<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Signage Player</title>
  <!-- Cache busting: v2.0 -->
  <meta name="color-scheme" content="dark light"/>
  <link rel="icon" href="data:,">

  <!-- Firebase for Analytics -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>

  <!-- Inline Configuration for Yodeck Compatibility -->
  <script>
    // Digital Signage Configuration
    // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô PROJECT_ID ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ project ‡∏≠‡∏∑‡πà‡∏ô
    window.CONFIG = {
      PROJECT_ID: 'prj004',  // <- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Ñ‡πà‡∏≤‡∏ô‡∏µ‡πâ: prj001, prj002, prj003, etc.
      DEFAULT_PAGE: 'index.html',
      VERSION: '1.0.1',
      DEVICE_ID: 'prj002-mahogany-main' // Unique device identifier
    };

    // Initialize Firebase
    if (!firebase.apps.length) {
      const firebaseConfig = {
        apiKey: "AIzaSy" + "CZ4TnAas5EY0iLrNP2m-NlMEh46hRe1d4",
        authDomain: "aquamx-system.firebaseapp.com",
        projectId: "aquamx-system",
        storageBucket: "aquamx-system.firebasestorage.app",
        messagingSenderId: "893876394311",
        appId: "1:893876394311:web:85541afc56d2325d631462"
      };
      firebase.initializeApp(firebaseConfig);
    }
    window.db = firebase.firestore();

    // Touch Analytics Tracker
    let touchCount = 0;
    let lastSyncTime = Date.now();
    const SYNC_INTERVAL = 60000; // Sync every 1 minute

    function trackTouch(element, action) {
      touchCount++;
      const touchData = {
        device_id: window.CONFIG.DEVICE_ID,
        project_id: window.CONFIG.PROJECT_ID,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        element: element || 'screen',
        action: action || 'touch',
        page: window.location.pathname.split('/').pop(),
        session_date: new Date().toISOString().split('T')[0]
      };

      // Send to Firestore
      db.collection('touch_analytics').add(touchData).catch(err => {
        console.error('Touch tracking error:', err);
      });

      // Update daily summary every minute
      const now = Date.now();
      if (now - lastSyncTime >= SYNC_INTERVAL) {
        updateDailySummary();
        lastSyncTime = now;
      }
    }

    function updateDailySummary() {
      if (touchCount === 0) return;

      const today = new Date().toISOString().split('T')[0];
      const summaryRef = db.collection('touch_summary').doc(`${window.CONFIG.DEVICE_ID}_${today}`);

      summaryRef.set({
        device_id: window.CONFIG.DEVICE_ID,
        project_id: window.CONFIG.PROJECT_ID,
        date: today,
        touch_count: firebase.firestore.FieldValue.increment(touchCount),
        last_updated: firebase.firestore.FieldValue.serverTimestamp()
      }, { merge: true }).then(() => {
        console.log(`‚úÖ Synced ${touchCount} touches to daily summary`);
        touchCount = 0;
      }).catch(err => {
        console.error('Summary sync error:', err);
      });
    }

    // Track all touches on the document
    document.addEventListener('touchstart', () => trackTouch('screen', 'touch'), { passive: true });
    document.addEventListener('click', () => trackTouch('screen', 'click'), { passive: true });

    // Sync remaining touches before page unload
    window.addEventListener('beforeunload', () => {
      if (touchCount > 0) {
        updateDailySummary();
      }
    });

    console.log('üîç Touch analytics enabled for', window.CONFIG.DEVICE_ID);
  </script>

  <style>
    :root{ --cta-bg: rgba(200,200,200,.35); --cta-border: rgba(255,255,255,.45); --cta-text: #fff; }

    *{box-sizing:border-box}
    html,body{margin:0;height:100%;background:#000}
    body{color:#333;overflow:hidden;font-family:system-ui,-apple-system,"Segoe UI",Tahoma,Arial,sans-serif}

    /* ‚úÖ ‡∏Å‡∏£‡∏≠‡∏ö‡∏Å‡∏•‡∏≤‡∏á‡∏à‡∏≠ + ‡∏™‡πÄ‡∏Å‡∏•‡∏ó‡∏±‡πâ‡∏á‡πÄ‡∏ü‡∏£‡∏° (‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö announce.html) */
    .safe-viewport{position:fixed;inset:0;display:grid;place-items:center;overflow:hidden}
    #frame{position:absolute;left:50%;top:50%;width:1080px;height:1920px;background:#000;overflow:hidden;
           transform:translate(-50%,-50%) scale(1);transform-origin:center center;will-change:transform}

    /* ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏∑‡πà‡∏≠ */
    .stage{position:absolute;inset:0;background:#000}
    video,img,iframe{position:absolute;inset:0;width:100%;height:100%;background:#000}
    video,img{object-fit:contain} /* ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å cover ‡πÑ‡∏î‡πâ‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏£‡∏≠‡∏ö */
    iframe{border:0}

    /* ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ */
    #status{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
      color:#ddd;font-weight:700;text-align:center;z-index:90;padding:10px 14px;border-radius:10px;
      background:rgba(0,0,0,.35);display:none}
    #status.show{display:block}

    /* ‚úÖ CTA overlays (matching announce.html) */
    .cta-head, .cta-main {
      position: absolute;
      z-index: 80;
      font-size: 60px;
      font-weight: 700;
      letter-spacing: .5px;
      text-shadow: 0 2px 6px rgba(0,0,0,.45);
      color: #fff;
      user-select: none;
      pointer-events: none;
    }
    .cta-head { top: 24px; left: 24px; }
    .cta-main { top: 24px; right: 24px; pointer-events: auto; cursor: pointer; }

    /* Position swipeable buttons */
    #ctaHead.swipe-button {
      top: 24px;
      left: 24px;
      margin-left: 40px; /* Space for ball on left */
    }
    #ctaMain.swipe-button {
      top: 24px;
      right: 24px;
      margin-right: 40px; /* Space for ball on right */
      margin-left: 0;
    }
    .blink { animation: blink 1.2s ease-in-out infinite; }
    @keyframes blink { 0%,100%{opacity:1} 50%{opacity:.35} }

    #headCta{position:absolute;left:24px;top:24px;z-index:80;display:flex}
    #floatCta{
      margin:0;padding:8px 14px;border:0;border-radius:999px;background:transparent;box-shadow:none;color:#fff;
      font-weight:700;font-size:40px;letter-spacing:.5px;text-shadow:0 2px 6px rgba(0,0,0,.45);
      display:none;align-items:center;gap:8px;max-inline-size:min(72%,520px);
      white-space:normal;overflow-wrap:anywhere;hyphens:auto;text-wrap:balance;
      user-select:none;pointer-events:auto;cursor:pointer;-webkit-tap-highlight-color:transparent;
    }
    #floatCta:hover{opacity:.9} #floatCta:active{opacity:.75}

    .blink{animation:blink 1.2s ease-in-out infinite}
    @keyframes blink{0%,100%{opacity:1}50%{opacity:.35}}

    /* ‡∏õ‡∏∏‡πà‡∏°‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏™‡∏µ‡∏¢‡∏á */
    #unlock{
      position:absolute;right:16px;top:16px;z-index:100;
      padding:10px 14px;border-radius:10px;border:0;cursor:pointer;
      font:600 15px system-ui;background:#1a73e8;color:#fff;
      box-shadow:0 6px 18px rgba(0,0,0,.32);display:none;
    }

    #ver{position:absolute;left:12px;bottom:12px;z-index:100;font-size:12px;color:#9aa5b1;opacity:.7;user-select:none}

    /* Smooth fade transitions for announcements */
    #img, #ann, #web {
      transition: opacity 0.75s ease-in-out;
    }

    .fade-out {
      opacity: 0 !important;
    }

    .fade-in {
      opacity: 1 !important;
    }

    /* Swipeable Button Styles */
    .swipe-button {
      position: absolute;
      z-index: 80;
      display: inline-flex;
      align-items: center;
      padding: 12px 20px 12px 54px;
      background: rgba(42, 42, 42, 0.4);
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 50px;
      color: #e0e0e0;
      font-size: 32px;
      font-weight: 700;
      letter-spacing: 0.5px;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      animation: blink 1.2s ease-in-out infinite;
      pointer-events: auto;
      user-select: none;
      overflow: visible;
    }

    .swipe-button .arrow-circle {
      position: absolute;
      left: -32px;
      top: 50%;
      transform: translateY(-50%);
      width: 72px;
      height: 72px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      z-index: 10;
      cursor: grab;
      pointer-events: auto;
      transition: left 0.3s ease, right 0.3s ease, box-shadow 0.3s ease;
    }

    /* Swipe to Explore - Blue */
    #ctaHead .arrow-circle {
      background: rgba(0, 29, 86, 0.7); /* Blue #001D56 */
      box-shadow: 0 0 25px rgba(0, 29, 86, 0.5);
    }

    /* Swipe to Menu - Orange */
    #ctaMain .arrow-circle {
      background: rgba(192, 107, 47, 0.7); /* Orange #C06B2F */
      box-shadow: 0 0 25px rgba(192, 107, 47, 0.5);
    }

    .swipe-button .arrow-circle.dragging {
      cursor: grabbing;
      transition: none;
      box-shadow: 0 0 40px rgba(0, 255, 136, 0.9);
    }

    .swipe-button.dragging {
      animation: none;
    }

    .swipe-button.dragging .arrow-icon {
      animation: none;
    }

    .swipe-button .arrow-icon {
      position: relative;
      width: 28px;
      height: 28px;
      animation: slideRight 2s ease-in-out infinite;
    }

    .swipe-button .arrow-icon::before,
    .swipe-button .arrow-icon::after {
      content: '';
      position: absolute;
      background: #ffffff;
      border-radius: 2px;
    }

    .swipe-button .arrow-icon::before {
      width: 20px;
      height: 3px;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
    }

    .swipe-button .arrow-icon::after {
      width: 12px;
      height: 12px;
      right: 0;
      top: 50%;
      transform: translateY(-50%) rotate(45deg);
      border-right: 3px solid #ffffff;
      border-top: 3px solid #ffffff;
      background: transparent;
    }

    .swipe-button .button-text {
      white-space: nowrap;
      position: relative;
      transition: opacity 0.1s linear;
    }

    /* Hover states with respective colors */
    #ctaHead:hover .arrow-circle {
      background: rgba(192, 107, 47, 0.5); /* Orange hover */
      box-shadow: 0 0 30px rgba(192, 107, 47, 0.7);
    }

    #ctaMain:hover .arrow-circle {
      background: rgba(0, 29, 86, 0.5); /* Blue hover */
      box-shadow: 0 0 30px rgba(0, 29, 86, 0.7);
    }

    /* Reverse direction swipe button (ball on right, swipes left) */
    .swipe-button.reverse {
      padding: 12px 54px 12px 20px; /* Mirrored padding: right side for ball */
    }

    .swipe-button.reverse .arrow-circle {
      left: auto;
      right: -32px; /* Position on right side */
      cursor: grab;
      pointer-events: auto;
      z-index: 100;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    .swipe-button.reverse .arrow-circle.dragging {
      cursor: grabbing;
    }

    /* Reverse arrow - pointing left <-- */
    .swipe-button.reverse .arrow-icon::before {
      /* Shaft extends from left to right */
      width: 18px;
      height: 3px;
      left: 0;
      top: 50%;
      right: auto;
      transform: translateY(-50%);
    }

    .swipe-button.reverse .arrow-icon::after {
      /* Arrow head on left side pointing left < */
      width: 9px;
      height: 9px;
      left: -1px;
      top: 50%;
      right: auto;
      transform: translateY(-50%) rotate(45deg);
      border-left: 3px solid #ffffff;
      border-bottom: 3px solid #ffffff;
      border-right: none;
      border-top: none;
      background: transparent;
    }

    .swipe-button.reverse .arrow-icon {
      animation: slideLeft 2s ease-in-out infinite;
    }

    @keyframes slideLeft {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(-5px); }
    }

    /* Video navigation buttons (back/next) */
    .nav-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      z-index: 80;
      display: inline-flex;
      align-items: center;
      color: #e0e0e0;
      font-size: 138px;
      font-weight: 700;
      cursor: pointer;
      animation: blink 1.2s ease-in-out infinite;
      pointer-events: auto;
      user-select: none;
      transition: all 0.3s ease;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .nav-button:hover {
      transform: translateY(-50%) scale(1.1);
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
    }

    .nav-button:active {
      transform: translateY(-50%) scale(0.95);
    }

    #navBack {
      left: 24px;
    }

    #navNext {
      right: 24px;
    }

    /* CTA Action Button Overlay */
    #ctaActionBtn {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 85;
      display: none;
      padding: 20px 60px;
      background: linear-gradient(135deg, rgba(255, 107, 0, 0.475), rgba(255, 152, 0, 0.475));
      border: 3px solid rgba(255, 255, 255, 0.45);
      border-radius: 50px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 48px;
      font-weight: 700;
      letter-spacing: 1px;
      text-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      user-select: none;
      pointer-events: auto;
      box-shadow: 0 8px 30px rgba(255, 107, 0, 0.3), 0 0 50px rgba(255, 152, 0, 0.2);
      animation: ctaPulse 2s ease-in-out infinite, ctaTextFlash 0.8s ease-in-out infinite;
    }

    #ctaActionBtn:hover {
      transform: translateX(-50%) scale(1.05);
      box-shadow: 0 10px 40px rgba(255, 107, 0, 0.4), 0 0 60px rgba(255, 152, 0, 0.3);
    }

    #ctaActionBtn:active {
      transform: translateX(-50%) scale(0.98);
    }

    @keyframes ctaPulse {
      0%, 100% {
        transform: translateX(-50%) scale(1);
        box-shadow: 0 8px 30px rgba(255, 107, 0, 0.3), 0 0 50px rgba(255, 152, 0, 0.2);
      }
      50% {
        transform: translateX(-50%) scale(1.03);
        box-shadow: 0 10px 35px rgba(255, 107, 0, 0.35), 0 0 60px rgba(255, 152, 0, 0.25);
      }
    }

    @keyframes ctaTextFlash {
      0%, 100% {
        color: rgba(255, 255, 255, 0.6);
      }
      50% {
        color: rgba(255, 255, 255, 1);
      }
    }

  </style>
</head>
<body>

  <div class="safe-viewport">
    <!-- ‚úÖ ‡πÄ‡∏ü‡∏£‡∏°‡∏Ñ‡∏á‡∏ó‡∏µ‡πà 1080√ó1920 -->
    <div id="frame">
      <div class="stage" aria-live="polite">
        <!-- A) ‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠/‡∏£‡∏π‡∏õ -->
        <video id="v" playsinline preload="auto" muted></video>
        <img id="img" alt=""/>

        <!-- B) ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏® (iframe) -->
        <iframe id="ann" allow="autoplay; fullscreen" style="display:none"></iframe>

        <!-- C) URL ‡∏≠‡∏∑‡πà‡∏ô ‡πÜ -->
        <iframe id="web" allow="autoplay; fullscreen" style="display:none"></iframe>

        <!-- D) Menu preview overlay -->
        <iframe id="menuPreview" src="./menu.html" allow="autoplay; fullscreen" style="display:none; position:absolute; inset:0; width:100%; height:100%; border:0; z-index:70;"></iframe>
      </div>

      <!-- Working overlays for video player -->
      <div id="ctaHead" class="swipe-button" tabindex="0">
        <div class="arrow-circle">
          <div class="arrow-icon"></div>
        </div>
        <span class="button-text">Swipe to Explore</span>
      </div>
      <div id="ctaMain" class="swipe-button reverse" tabindex="0">
        <div class="arrow-circle">
          <div class="arrow-icon"></div>
        </div>
        <span class="button-text">Swipe to Menu</span>
      </div>

      <!-- Video navigation buttons -->
      <div id="navBack" class="nav-button" tabindex="0">¬´</div>
      <div id="navNext" class="nav-button" tabindex="0">¬ª</div>

      <!-- CTA Action Button -->
      <div id="ctaActionBtn" tabindex="0"></div>

      <!-- overlay ‡∏≠‡∏∑‡πà‡∏ô‡πÉ‡∏ô‡πÄ‡∏ü‡∏£‡∏° -->
      <div id="status"></div>
      <div id="ver"></div>
      <!-- Audio button removed -->
    </div>
  </div>

  <!-- BGM element kept for compatibility but muted -->
  <audio id="bgm" preload="auto" playsinline muted></audio>

  <script>
    /* =============== fit ‡πÄ‡∏ü‡∏£‡∏°‡πÉ‡∏´‡πâ‡∏û‡∏≠‡∏î‡∏µ‡∏à‡∏≠ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô announce.html) =============== */
    (function fit(){
      const DESIGN_W=1080, DESIGN_H=1920, frame=document.getElementById('frame');
      function apply(){
        const s=Math.min(window.innerWidth/DESIGN_W, window.innerHeight/DESIGN_H);
        frame.style.transform=`translate(-50%,-50%) scale(${s})`;
      }
      addEventListener('resize',apply); addEventListener('orientationchange',apply);
      addEventListener('pageshow',apply); addEventListener('DOMContentLoaded',apply);
    })();

    /* ===================== BGM ===================== */
    (function bgmLoop(){
      const audio  = document.getElementById('bgm');
      window.elBgm = audio;

      // Disable background music for deployment package (no music files available)
      const tracks = []; // Empty array - no background music files
      let i = 0;
      audio.volume = 0; audio.loop = false; audio.muted = true;

      function playCurrent(){
        if (tracks.length === 0) return; // Skip if no tracks available
        audio.src = tracks[i];
        const p = audio.play();
        if (p && p.catch) {
          const unlock = () => { audio.play().catch(()=>{}); window.removeEventListener('pointerdown', unlock); };
          window.addEventListener('pointerdown', unlock, { once:true });
        }
      }
      audio.addEventListener('ended', () => { i = (i+1) % tracks.length; playCurrent(); });
      audio.addEventListener('error', () => { i = (i+1) % tracks.length; playCurrent(); });
      // Disabled: document.addEventListener('DOMContentLoaded', playCurrent);
      audio.nextTrack = () => { i = (i+1) % tracks.length; playCurrent(); };
    })();

    /* ===================== Core ===================== */
  (function(){
    const IMG_DURATION_SEC = 10;
    const URL_DURATION_SEC = 20;
		const ANNOUNCE_GUARD_MS = 5000;   // guard ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏£‡∏ì‡∏µ‡∏û‡∏±‡∏á/‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì
    const VERSION_POLL_MS = 21_600_000;

    // Global user interaction detection for autoplay enablement
    let hasUserInteracted = false;
    const enableAutoplay = () => { hasUserInteracted = true; };
    ['click', 'touchstart', 'keydown'].forEach(event => {
      document.addEventListener(event, enableAutoplay, { once: true });
    });

    const qs = new URLSearchParams(location.search);

    const playlistPath = `./project/data/playlist.json`;
    const mediasPath   = `./project/data/medias.json`;

    const elV   = document.getElementById('v');
    const elImg = document.getElementById('img');
    const ifrAnn= document.getElementById('ann');
    const elWeb = document.getElementById('web');
    const elStat= document.getElementById('status');
    const elVer = document.getElementById('ver');
    const ctaMain=document.getElementById('ctaMain');
    const ctaHead=document.getElementById('ctaHead');
    const unlockBtn=document.getElementById('unlock');
    const ctaActionBtn=document.getElementById('ctaActionBtn');

    const isHttpUrl = s => typeof s==='string' && /^https?:\/\//i.test(s);
    const extOf = p => { const m=(p||'').match(/\.([a-z0-9]+)(?:[?#]|$)/i); return m?m[1].toLowerCase():''; };
    const sleep = ms => new Promise(r=>setTimeout(r,ms));
    const todayISO=()=>new Date().toISOString().slice(0,10);

    function isiOSSafari(){
      const ua=navigator.userAgent;
      const isiOS=/iPad|iPhone|iPod/.test(ua);
      const isSafari=/^((?!chrome|android).)*safari/i.test(ua);
      return isiOS || isSafari;
    }
    function withinDateRange(m){
      const t=todayISO(), s=m.start_date||null, e=m.end_date||null;
      if(s && t<s) return false; if(e && t>e) return false; return true;
    }
    function showStatus(msg){
      if(!msg){
        hideStatus();
        return;
      }
      elStat.textContent=msg;
      elStat.classList.add('show');
    }
    function hideStatus(){
      elStat.classList.remove('show');
      elStat.textContent='';
    }

    // Helper function for smooth fade transitions
    async function fadeOut(element) {
      element.classList.add('fade-out');
      element.classList.remove('fade-in');
      await sleep(750); // Wait for fade out to complete
      element.style.display = 'none';
      element.classList.remove('fade-out');
    }

    function fadeIn(element) {
      element.style.display = 'block';
      element.classList.remove('fade-out');
      element.classList.add('fade-in');
    }

    function hideAll(){
      elV.pause(); elV.removeAttribute('src'); elV.load(); elV.style.display='none';
      elImg.removeAttribute('src'); elImg.style.display='none';
      elWeb.src='about:blank'; elWeb.style.display='none';
      ifrAnn.src='about:blank'; ifrAnn.style.display='none';
      // Remove any transition classes
      elImg.classList.remove('fade-in', 'fade-out');
      elWeb.classList.remove('fade-in', 'fade-out');
      ifrAnn.classList.remove('fade-in', 'fade-out');
      // Hide CTA button
      hideCtaButton();
    }

    function buildMainMenuUrl(){
      return './menu.html';
    }

    function buildDetailUrl(meta){
      if(!meta) return null;
      const ref=(meta.id_ref||''); if(!ref) return null;
      const id=encodeURIComponent(meta.id_ref);


      // Determine type based on meta or item kind
      let type = 'unit'; // default for property listings
      if(meta.kind === 'restaurant' || ref.startsWith('rest') || ref.startsWith('dine')) type = 'restaurant';
      else if(meta.kind === 'shop' || ref.startsWith('shop') || ref.startsWith('od')) type = 'shop';

      const url = new URL('./product.html', location.href);
      url.searchParams.set('type', type);
      url.searchParams.set('id', ref);

      return url.toString();
    }

    // ‡∏ó‡∏≥ path ‡∏™‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô relative path ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö deployment package
    function resolveMediaSrc(s){
      if(!s) return s;
      if (/^https?:\/\//i.test(s)) return s;

      let resolved = s;

      // Convert /ann/medias/xxx.mp4 to ./medias/xxx.MP4
      if (s.startsWith('/ann/')) {
        resolved = './' + s.replace(/^\/ann\//, '');
      } else if (s.startsWith('/')) {
        resolved = '.' + s;
      }

      // Fix case sensitivity: .mp4 -> .MP4 for video files
      if (resolved.endsWith('.mp4')) {
        resolved = resolved.replace('.mp4', '.MP4');
      }

      return resolved;
    }

    async function loadJson(path){
      const res=await fetch(path,{cache:'default'});  // Allow browser caching for better performance
      if(!res.ok) {
        const error = `HTTP ${res.status} ${res.statusText} @ ${path}`;
        console.error('loadJson failed:', error);
        throw new Error(error);
      }
      return res.json();
    }

    // ---------- ‡∏•‡∏¥‡∏™‡∏ï‡πå‡πÄ‡∏•‡πà‡∏ô: ‡πÉ‡∏™‡πà‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏ï‡πà‡∏≠‡πÄ‡∏û‡∏•‡∏¢‡πå‡∏•‡∏¥‡∏™‡∏ï‡πå ----------
    async function buildSequence(){
      let playlistData, medias;
      try {
        console.log('Loading playlist from:', playlistPath);
        playlistData = await loadJson(playlistPath);
        console.log('Loaded playlist:', playlistData);
      } catch (e) {
        console.error('Failed to load playlist:', e);
        console.warn('Using fallback playlist data due to network/server error');
        showStatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡∏£‡∏≠‡∏á (Fallback mode)');
        setTimeout(hideStatus, 3000); // Hide after 3 seconds
        // Fallback playlist data for signage screens
        playlistData = {
          "loop": true,
          "items": [
            { "media_id": "unit001-01" },
            { "media_id": "shop001-01" }
          ]
        };
      }

      try {
        console.log('Loading medias from:', mediasPath);
        medias = await loadJson(mediasPath);
        console.log('Loaded medias:', medias);
      } catch (e) {
        console.error('Failed to load medias:', e);
        console.warn('Using fallback medias data due to network/server error');
        // Fallback medias data for signage screens
        medias = {
          "version": "1.0.0",
          "medias": [
            {
              "media_id": "unit001-01",
              "id_ref": "unit001",
              "media_type": "video",
              "file_name": "./medias/unit001-01.MP4",
              "approval_status": "approved",
              "start_date": "2025-01-01"
            },
            {
              "media_id": "shop001-01",
              "id_ref": "shop001",
              "media_type": "video",
              "file_name": "./medias/shop001-01.MP4",
              "approval_status": "approved",
              "start_date": "2025-01-01"
            }
          ]
        };
      }

      // Fix: playlist.json is a direct object, not wrapped in playlists
      let pl = {items:[],loop:true};
      if (playlistData) {
        pl = playlistData;
      }

      const ids=(pl.items||[]).map(x=>x.media_id);
      const list=Array.isArray(medias?.medias)?medias.medias:[];
      const byId=new Map(list.map(m=>[m.media_id,m]));
      const out=[];

      console.log('DEBUG buildSequence - Playlist data:', playlistData);
      console.log('DEBUG buildSequence - Media IDs to find:', ids);
      console.log('DEBUG buildSequence - Available medias:', list.map(m => m.media_id));

// Add all announcements for this project as first items
      let announcements = [];
      try {
        const announceRes = await fetch('./project/data/announce.json', {cache: 'no-store'});
        announcements = await announceRes.json();

        // Find all active announcements
        const projectAnnouncements = announcements.filter(a =>
          a.status === 'active'
        );

        // Add each announcement as a separate item
        projectAnnouncements.forEach((announcement, index) => {
          out.push({
            kind:'announcement',
            duration: Math.floor((announcement.display_duration || 8000) / 1000), // Convert ms to seconds
            meta: {
              id_ref: `announce:${announcement.announcement_id}`,
              announcement_data: announcement // Include the actual announcement data
            }
          });
        });
      } catch (error) {
        console.error('Failed to load announcements:', error);
        console.warn('Using fallback announcements data for signage');
        // Fallback announcements data for signage screens
        announcements = [
          {
            "announcement_id": "deep-cleaning-prj001",
            "title": "Deep Cleaning Services",
            "description": "Professional carpet cleaning services",
            "image_url": "images/announcements/deep-cleaning-prj001.jpg",
            "display_duration": 8000,
            "status": "active",
            "created_date": "2025-01-01"
          },
          {
            "announcement_id": "security-upgrade-prj001",
            "title": "Security System Update",
            "description": "New security patch installation",
            "image_url": "images/announcements/security-upgrade-prj001.jpg",
            "display_duration": 8000,
            "status": "active",
            "created_date": "2025-01-01"
          }
        ];

        // Process fallback announcements
        const projectAnnouncements = announcements.filter(a =>
          a.status === 'active'
        );

        projectAnnouncements.forEach((announcement, index) => {
          out.push({
            kind:'announcement',
            duration: Math.floor((announcement.display_duration || 8000) / 1000),
            meta: {
              id_ref: `announce:${announcement.announcement_id}`,
              announcement_data: announcement
            }
          });
        });
      }

      for(const id of ids){
        console.log(`DEBUG processing media ID: ${id}`);
        const m=byId.get(id);
        if(!m) {
          console.log(`DEBUG media not found for ID: ${id}`);
          continue;
        }

        console.log(`DEBUG found media:`, m);

        const approved=(m.approval_status||'').toLowerCase()==='approved';
        const inDate=withinDateRange(m);
        const inProject=true;

        console.log(`DEBUG filters - approved: ${approved}, inDate: ${inDate}, inProject: ${inProject}`);

        if(!approved||!inDate||!inProject) {
          console.log(`DEBUG media filtered out:`, m);
          continue;
        }

        let kind='video',src=m.file_name,duration=0;
        const ext=extOf(m.file_name);
        if(m.media_type==='image' || ['jpg','jpeg','png','gif','webp'].includes(ext)){
          kind='image'; duration=IMG_DURATION_SEC;
        }else if(m.media_type==='url' || isHttpUrl(m.file_name)){
          kind='url'; duration=URL_DURATION_SEC;
        }else{ kind='video'; }
        src = resolveMediaSrc(src);

        console.log(`DEBUG adding to sequence - kind: ${kind}, src: ${src}`);

        out.push({kind,src,duration,meta:m});
      }

      const loop=pl?.loop!==false;

      // Insert menu preview items into the sequence
      const sequenceWithMenuPreviews = insertMenuPreviews(out);

      console.log(`üìã Final sequence: ${sequenceWithMenuPreviews.length} items (${out.length} original + ${sequenceWithMenuPreviews.length - out.length} menu previews)`);

      return {sequence:sequenceWithMenuPreviews,loop};
    }

    // CTA main ‚Üí menu.html
    function setupMainCta(){
      // Menu button is now handled by setupSwipeButtonReverse
      // No need to set up click handler here anymore
    }

    // CTA head - swipe to explore ‚Üí product page
    let headTargetUrl = null;
    function showHeadFor(meta){
      if(!meta || !meta.id_ref) return;

      // Special handling for announcements
      if(meta.id_ref.startsWith('announce:')) {
        const categoryUrl = './category.html?type=juristic';
        headTargetUrl = categoryUrl;
        const go = () => location.href = categoryUrl;
        ctaHead.onclick = go;
        ctaHead.onkeydown = e => { if(e.key==='Enter'||e.key===' ') go(); };
        ctaHead.style.pointerEvents = 'auto';
        return;
      }

      const url = buildDetailUrl(meta);
      if(!url) return;

      headTargetUrl = url; // Store for swipe completion
      const go = () => location.href = url;

      // Keep click functionality for fallback
      ctaHead.onclick = go;
      ctaHead.onkeydown = e => { if(e.key==='Enter'||e.key===' ') go(); };
      ctaHead.style.pointerEvents = 'auto';
    }

    // CTA Action Button - shows in center bottom of video with custom text
    function showCtaButton(cta, meta){
      if(!cta || !cta.text) {
        hideCtaButton();
        return;
      }

      const delay = (cta.delay || 2) * 1000; // Convert to ms

      // Hide initially
      ctaActionBtn.style.display = 'none';

      // Show after delay
      setTimeout(() => {
        ctaActionBtn.textContent = cta.text;
        ctaActionBtn.style.display = 'block';

        // Set up click handler
        const handleClick = () => {
          if(cta.action === 'navigate' && cta.url) {
            location.href = cta.url;
          } else if(cta.action === 'external' && cta.url) {
            window.open(cta.url, '_blank');
          }
        };

        ctaActionBtn.onclick = handleClick;
        ctaActionBtn.onkeydown = e => {
          if(e.key==='Enter'||e.key===' ') handleClick();
        };

        console.log('üì£ CTA button shown:', cta.text);
      }, delay);
    }

    function hideCtaButton(){
      if(ctaActionBtn) {
        ctaActionBtn.style.display = 'none';
        ctaActionBtn.onclick = null;
        ctaActionBtn.onkeydown = null;
      }
    }

    const lastKey='signage:lastIndex:prj003';
    let sequence=[],loopPlay=true,index=0;
    let skipCurrentItem = false; // Flag to skip current item when navigation buttons are clicked
    const MENU_PREVIEW_INTERVAL = 3; // Insert menu preview every 3 items
    const MENU_PREVIEW_DURATION = 10000; // Show menu for 10 seconds (10000ms)

    async function playAll(){
      hideStatus();
      if(sequence.length===0){showStatus('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏•‡πà‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå‡∏ô‡∏µ‡πâ');return;}
      const saved=parseInt(sessionStorage.getItem(lastKey)||'0',10);
      index=(!isNaN(saved)&&saved>=0&&saved<sequence.length)?saved:0;
      while(true){
        const item=sequence[index];
        sessionStorage.setItem(lastKey,String(index));
        try{await playItem(item);}catch(e){ console.error(e); }
        index++;
        if(index>=sequence.length){ if(!loopPlay) break; index=0; }
      }
    }

    // Preload next video in sequence for smooth playback
    function preloadNextVideo(){
      if (sequence.length === 0) return;

      const nextIndex = (index + 1) >= sequence.length ? 0 : index + 1;
      const nextItem = sequence[nextIndex];

      if (nextItem && nextItem.kind === 'video') {
        // Create a hidden video element to preload
        const preloadVideo = document.createElement('video');
        preloadVideo.preload = 'auto';
        preloadVideo.src = nextItem.src;
        preloadVideo.muted = true;
        preloadVideo.style.display = 'none';

        // Clean up after preload starts
        setTimeout(() => {
          if (preloadVideo.readyState >= 2) { // HAVE_CURRENT_DATA
            console.log('üì¶ Preloaded next video:', nextItem.src);
          }
        }, 1000);
      }
    }

    // Insert menu preview items into sequence
    function insertMenuPreviews(originalSequence) {
      const result = [];

      for (let i = 0; i < originalSequence.length; i++) {
        result.push(originalSequence[i]);

        // Insert menu preview after every MENU_PREVIEW_INTERVAL items
        if ((i + 1) % MENU_PREVIEW_INTERVAL === 0) {
          result.push({
            kind: 'menu_preview',
            duration: MENU_PREVIEW_DURATION / 1000, // Convert ms to seconds
            meta: { id_ref: 'menu_preview' }
          });
          console.log(`üìã Inserted menu preview after item ${i + 1}`);
        }
      }

      return result;
    }

    async function playItem(item){
      console.log(`üì∫ Playing: ${item.kind}`, item);

      hideAll();

      // Special handling for menu preview
      if (item.kind === 'menu_preview') {
        showHeadFor(null); // No "Swipe to Explore" for menu preview
      } else {
        showHeadFor(item.meta);
      }

      // Preload next video in sequence
      preloadNextVideo();

      // Simple like morning version - no overlay manipulation!

      if (item.kind === 'video') {
        elV.src = item.src;

        elV.loop = false;
        elV.style.display = 'block';
        elV.muted = true;

        // Show CTA button if configured for this video
        if (item.meta && item.meta.cta) {
          showCtaButton(item.meta.cta, item.meta);
        }

        // ===== BGM helpers =====
        const elBgm = window.elBgm;
        // BGM functions disabled
        const bgmPause  = () => { /* disabled */ };
        const bgmResume = () => { /* disabled */ };
        const bgmNext   = () => { /* disabled */ };

        // bgmPause(); // disabled

        function hasAudioNow(v){
          try {
            if ('audioTracks' in v && v.audioTracks && v.audioTracks.length > 0) return true;
            if (typeof v.mozHasAudio === 'boolean') return v.mozHasAudio;
            if (typeof v.webkitAudioDecodedByteCount === 'number') return v.webkitAudioDecodedByteCount > 0;
          } catch(_) {}
          return false;
        }

        const metaReady = new Promise(res => {
          if (!isFinite(elV.duration) || elV.duration === 0) {
            elV.addEventListener('loadedmetadata', () => res(), { once: true });
          } else { res(); }
        });
        await Promise.race([metaReady, sleep(2000)]);

        // Enhanced autoplay handling with user interaction detection
        try {
          await elV.play();
        } catch (err) {
          console.warn('Autoplay failed:', err.message);
          // Show unlock button for user interaction
          if (unlockBtn) {
            unlockBtn.style.display = 'block';
            unlockBtn.onclick = () => {
              elV.play().catch(e => console.warn('Manual play failed:', e));
              unlockBtn.style.display = 'none';
            };
          }
        }

        let usingVideoAudio = false;
        if (hasAudioNow(elV)) { usingVideoAudio = true; elV.muted = true; }
        else {
          await sleep(600);
          if (hasAudioNow(elV)) { usingVideoAudio = true; elV.muted = true; }
          else { /* bgmResume(); */ }
        }

        await new Promise(resolve => {
          const sec = (isFinite(elV.duration) && elV.duration > 0) ? elV.duration : 30;
          const watchdog = setTimeout(() => { if (usingVideoAudio) /* bgmNext() */; resolve(); }, Math.ceil(sec + 1) * 1000);
          elV.onended = () => { clearTimeout(watchdog); if (usingVideoAudio) /* bgmNext() */; skipCurrentItem = false; resolve(); };
          elV.onerror = () => { clearTimeout(watchdog); if (usingVideoAudio) /* bgmNext() */; skipCurrentItem = false; resolve(); };
        });

        // No overlay manipulation needed
      }
      else if(item.kind==='image'){
        elImg.src=item.src;
        fadeIn(elImg);

        // Wait with interruptible sleep
        const duration = (item.duration||IMG_DURATION_SEC)*1000;
        const startTime = Date.now();
        while (Date.now() - startTime < duration) {
          if (skipCurrentItem) {
            skipCurrentItem = false; // Reset flag
            break;
          }
          await sleep(100); // Check every 100ms
        }

        await fadeOut(elImg);
      }
      else if (item.kind === 'menu_preview') {
        // Display menu.html as iframe overlay
        const menuPreview = document.getElementById('menuPreview');
        const navBack = document.getElementById('navBack');
        const navNext = document.getElementById('navNext');

        if (!menuPreview) {
          console.error('Menu preview iframe not found');
          await sleep(2000);
          return;
        }

        console.log('üéØ Showing menu preview for', item.duration || 10, 'seconds...');

        // Show menu preview iframe
        menuPreview.style.display = 'block';

        // Hide CTA buttons during menu preview, but KEEP navigation buttons visible
        ctaHead.style.display = 'none';
        ctaMain.style.display = 'none';
        if (navBack) navBack.style.display = 'inline-flex';
        if (navNext) navNext.style.display = 'inline-flex';

        // Wait with interruptible sleep
        const duration = (item.duration || 10) * 1000;
        const startTime = Date.now();
        while (Date.now() - startTime < duration) {
          if (skipCurrentItem) {
            skipCurrentItem = false; // Reset flag
            console.log('‚è≠Ô∏è Menu preview skipped by user');
            break;
          }
          await sleep(100); // Check every 100ms
        }

        // Hide menu preview, restore CTAs
        menuPreview.style.display = 'none';
        ctaHead.style.display = 'inline-flex';
        ctaMain.style.display = 'inline-flex';

        console.log('‚úÖ Menu preview ended');
      }
      else if (item.kind === 'announcement') {
  // Direct announcement display - use pre-loaded announcement data

  try {
    let announcement = null;

    // Use pre-loaded announcement data if available
    if (item.meta.announcement_data) {
      announcement = item.meta.announcement_data;
    } else {
      // Fallback: load announcement data
      const announceRes = await fetch('./data/announce.json', {cache: 'no-store'});
      const announcements = await announceRes.json();
      announcement = announcements[0];
    }

    if (announcement) {
      // Transform announcement data EXACTLY like category.html does
      announcement.name_th = announcement.title_th || announcement.title_en || '‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏®';
      announcement.name_en = announcement.title_en || announcement.title_th || 'Announcement';
      announcement.id = announcement.announcement_id;

      // Hide CTA button for announcements
      hideCtaButton();

      // Override "Tap to explore" to go to category page for announcements
      ctaHead.onclick = () => {
        const categoryUrl = './category.html?type=juristic';
        location.href = categoryUrl;
      };

      // DEBUG: Log what we have
      console.log('ANNOUNCEMENT DATA:', announcement);
      console.log('ANNOUNCEMENT IMAGE:', announcement.image);

      // Use the announcement image path and convert to relative path
      let announcementImagePath = './project/medias/placeholder.jpg'; // Default fallback

      if (announcement.image || announcement.image_url) {
        const imageSource = announcement.image || announcement.image_url;
        // Handle absolute URLs (https://) and relative paths
        if (imageSource.startsWith('http://') || imageSource.startsWith('https://')) {
          announcementImagePath = imageSource; // Use absolute URL as-is
        } else if (imageSource.startsWith('images/')) {
          announcementImagePath = './' + imageSource;
        } else if (imageSource.startsWith('/ann/')) {
          announcementImagePath = './' + imageSource.replace(/^\/ann\//, '');
        } else {
          announcementImagePath = imageSource;
        }
      }

      console.log('FINAL IMAGE PATH:', announcementImagePath);

      // Fallback to placeholder if specific announcement image doesn't exist
      elImg.onerror = () => {
        console.warn('Announcement image failed to load:', announcementImagePath);
        elImg.src = './project/medias/placeholder.jpg';
      };

      elImg.src = announcementImagePath;
      fadeIn(elImg);

      // Wait with interruptible sleep
      const duration = (item.duration || 15) * 1000;
      const startTime = Date.now();
      while (Date.now() - startTime < duration) {
        if (skipCurrentItem) {
          skipCurrentItem = false; // Reset flag
          break;
        }
        await sleep(100); // Check every 100ms
      }

      await fadeOut(elImg);
    } else {
      // No announcement found, just wait
      console.warn('No announcement found for:', item.meta);
      await sleep(2000);
    }
  } catch (error) {
    console.error('Error displaying announcement:', error);
    await sleep(2000);
  }
}
      else if(item.kind==='url'){
        // Morning version - no overlay manipulation
        let watchdog = null;
        let timeoutId = null;

        await new Promise(resolve=>{
          const done=()=>{
            if (watchdog) clearTimeout(watchdog);
            if (timeoutId) clearTimeout(timeoutId);
            try{elWeb.src='about:blank';}catch{}
            resolve();
          };

          // Check for skip flag periodically
          const checkSkip = () => {
            if (skipCurrentItem) {
              skipCurrentItem = false;
              done();
            }
          };

          watchdog = setTimeout(done, Math.max((item.duration||URL_DURATION_SEC),5)*1000 + 3000);

          elWeb.onload = ()=>{
            timeoutId = setTimeout(done, (item.duration||URL_DURATION_SEC)*1000);
            // Check skip flag every 100ms
            const skipInterval = setInterval(() => {
              checkSkip();
              if (!watchdog) clearInterval(skipInterval);
            }, 100);
          };

          elWeb.onerror= ()=>{ showStatus('‡πÇ‡∏´‡∏•‡∏î‡∏´‡∏ô‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à'); setTimeout(done, 1500); };
          elWeb.src=item.src; elWeb.style.display='block';
        });
      }
    }

    function setupUnlock(){
      // Audio unlock disabled - no functionality needed
      return;
    }

    // Setup swipe functionality for ctaHead button
    function setupSwipeButton(){
      const button = ctaHead;
      const circle = button.querySelector('.arrow-circle');
      const text = button.querySelector('.button-text');

      if (!circle || !text) return;

      let isDragging = false;
      let startX = 0;
      let currentX = 0;
      let initialLeft = -32;

      function getMaxDistance() {
        const buttonWidth = button.offsetWidth;
        const circleWidth = circle.offsetWidth;
        return buttonWidth - circleWidth / 2 - 20;
      }

      function updateTextVisibility(progress) {
        const textBounds = text.getBoundingClientRect();
        const circleBounds = circle.getBoundingClientRect();
        const overlap = Math.max(0, Math.min(circleBounds.right, textBounds.right) - Math.max(circleBounds.left, textBounds.left));
        const textWidth = textBounds.width;
        const hideProgress = Math.min(1, overlap / textWidth);
        text.style.opacity = 1 - hideProgress;
      }

      function startDrag(e) {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        currentX = parseInt(circle.style.left || initialLeft);
        circle.classList.add('dragging');
        button.classList.add('dragging', 'swiping');
        e.preventDefault();
        e.stopPropagation();
      }

      function onDrag(e) {
        if (!isDragging) return;
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        const deltaX = clientX - startX;
        const newLeft = Math.max(initialLeft, Math.min(currentX + deltaX, getMaxDistance()));
        circle.style.left = `${newLeft}px`;
        const maxDist = getMaxDistance() - initialLeft;
        const progress = Math.max(0, Math.min(1, (newLeft - initialLeft) / maxDist));
        updateTextVisibility(progress);
        e.preventDefault();
      }

      function endDrag(e) {
        if (!isDragging) return;
        isDragging = false;
        circle.classList.remove('dragging');
        button.classList.remove('dragging');

        const currentLeft = parseInt(circle.style.left || initialLeft);
        const maxDist = getMaxDistance();
        const progress = (currentLeft - initialLeft) / (maxDist - initialLeft);

        if (progress >= 0.75) {
          // Success! Navigate to detail page
          circle.style.left = `${maxDist}px`;
          text.style.opacity = '0';
          setTimeout(() => {
            if (headTargetUrl) {
              location.href = headTargetUrl;
            }
          }, 200);
        } else {
          // Reset to initial position
          resetSwipe();
        }
      }

      function resetSwipe() {
        button.classList.remove('swiping');
        circle.style.left = `${initialLeft}px`;
        text.style.opacity = '1';
      }

      // Mouse events
      circle.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', endDrag);

      // Touch events
      circle.addEventListener('touchstart', startDrag, { passive: false });
      document.addEventListener('touchmove', onDrag, { passive: false });
      document.addEventListener('touchend', endDrag);

      // Prevent default click on button when dragging
      button.addEventListener('click', (e) => {
        if (button.classList.contains('swiping')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });
    }

    // Setup reverse swipe functionality for ctaMain (Menu) button - EXACT COPY of setupSwipeButton but mirrored
    function setupSwipeButtonReverse(){
      const button = ctaMain;
      const circle = button.querySelector('.arrow-circle');
      const text = button.querySelector('.button-text');

      if (!circle || !text) return;

      let isDragging = false;
      let startX = 0;
      let currentX = 0;
      let initialRight = -32; // Same as initialLeft but for right side

      function getMaxDistance() {
        const buttonWidth = button.offsetWidth;
        const circleWidth = circle.offsetWidth;
        return buttonWidth - circleWidth / 2 - 20;
      }

      function updateTextVisibility(progress) {
        const textBounds = text.getBoundingClientRect();
        const circleBounds = circle.getBoundingClientRect();
        const overlap = Math.max(0, Math.min(circleBounds.right, textBounds.right) - Math.max(circleBounds.left, textBounds.left));
        const textWidth = textBounds.width;
        const hideProgress = Math.min(1, overlap / textWidth);
        text.style.opacity = 1 - hideProgress;
      }

      function startDrag(e) {
        isDragging = true;
        startX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        currentX = parseInt(circle.style.right || initialRight);
        circle.classList.add('dragging');
        button.classList.add('dragging', 'swiping');
        e.preventDefault();
        e.stopPropagation();
      }

      function onDrag(e) {
        if (!isDragging) return;
        const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
        const deltaX = startX - clientX; // Reversed for right-to-left movement
        const newRight = Math.max(initialRight, Math.min(currentX + deltaX, getMaxDistance()));
        circle.style.right = `${newRight}px`;
        const maxDist = getMaxDistance() - initialRight;
        const progress = Math.max(0, Math.min(1, (newRight - initialRight) / maxDist));
        updateTextVisibility(progress);
        e.preventDefault();
      }

      function endDrag(e) {
        if (!isDragging) return;
        isDragging = false;
        circle.classList.remove('dragging');
        button.classList.remove('dragging');

        const currentRight = parseInt(circle.style.right || initialRight);
        const maxDist = getMaxDistance();
        const progress = (currentRight - initialRight) / (maxDist - initialRight);

        if (progress >= 0.75) {
          // Success! Navigate to menu page
          circle.style.right = `${maxDist}px`;
          text.style.opacity = '0';
          setTimeout(() => {
            location.href = './menu.html';
          }, 200);
        } else {
          // Reset to initial position
          resetSwipe();
        }
      }

      function resetSwipe() {
        button.classList.remove('swiping');
        circle.style.right = `${initialRight}px`;
        text.style.opacity = '1';
      }

      // Mouse events
      circle.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('mouseup', endDrag);

      // Touch events
      circle.addEventListener('touchstart', startDrag, { passive: false });
      document.addEventListener('touchmove', onDrag, { passive: false });
      document.addEventListener('touchend', endDrag);

      // Prevent default click on button when dragging
      button.addEventListener('click', (e) => {
        if (button.classList.contains('swiping')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
        // Normal click - navigate to menu
        location.href = './menu.html';
      });
    }

    // Video navigation functions
    function setupVideoNavigation(){
      const navBackBtn = document.getElementById('navBack');
      const navNextBtn = document.getElementById('navNext');

      if (!navBackBtn || !navNextBtn) return;

      // Navigate to previous video
      navBackBtn.addEventListener('click', () => {
        if (sequence.length === 0) return;

        // Set index to previous - 1 (because playAll will increment after current item ends)
        index = index - 2;
        if (index < -1) {
          index = sequence.length - 2; // Wrap to end
        }
        if (index < 0) index = sequence.length - 1;

        sessionStorage.setItem(lastKey, String(index + 1)); // Save the actual target

        // Skip current item (works for all types: video, announcement, url, menu preview)
        skipCurrentItem = true;

        // Also end video if it's playing
        if (elV && elV.duration) {
          elV.currentTime = elV.duration;
        }
      });

      // Navigate to next video
      navNextBtn.addEventListener('click', () => {
        if (sequence.length === 0) return;

        // Keep index as is (playAll will increment to next)
        // Don't change index

        sessionStorage.setItem(lastKey, String(index + 1)); // Save next index

        // Skip current item (works for all types: video, announcement, url, menu preview)
        skipCurrentItem = true;

        // Also end video if it's playing
        if (elV && elV.duration) {
          elV.currentTime = elV.duration;
        }
      });

      // Keyboard support
      navBackBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          navBackBtn.click();
        }
      });

      navNextBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          navNextBtn.click();
        }
      });
    }

    (function pollVersion(){
      let cur='';
      async function tick(){
        try{
          const r=await fetch('./version.txt',{cache:'no-store'});
          if(r.ok){
            const t=(await r.text()).trim();
            if(cur && t && t!==cur) location.reload();
            cur=t; elVer.textContent=t?`v ${t}`:'';
          }
        }catch(e){}
      }
      tick(); setInterval(tick, VERSION_POLL_MS);
    })();

    // Register Service Worker for media caching
    function registerServiceWorker(){
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            console.log('‚úÖ Service Worker registered successfully:', registration.scope);

            // Wait for Service Worker to be ready (handles both first load and subsequent loads)
            return navigator.serviceWorker.ready;
          })
          .then((registration) => {
            console.log('‚úÖ Service Worker is ready and active');
            // Preload will be called after sequence is built
          })
          .catch((error) => {
            console.error('‚ùå Service Worker registration failed:', error);
          });

        // Listen for download progress messages from Service Worker
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data.action === 'downloadProgress') {
            const { current, total, url } = event.data;
            const percent = Math.round((current / total) * 100);
            console.log(`üì• Downloading media: ${current}/${total} (${percent}%)`);
            showStatus(`Downloading media to device: ${current}/${total} (${percent}%)`);
          }

          if (event.data.action === 'downloadComplete') {
            const { downloaded, total } = event.data;
            console.log(`‚úÖ All media files stored on device: ${downloaded}/${total}`);
            showStatus(`‚úÖ Ready! All ${downloaded} media files stored on device`);
            setTimeout(() => hideStatus(), 3000); // Hide status after 3 seconds
          }

          if (event.data.action === 'alreadyCached') {
            const { total } = event.data;
            console.log(`‚úÖ All ${total} media files already cached on device`);
            showStatus(`‚úÖ Ready! All ${total} media files already on device`);
            setTimeout(() => hideStatus(), 2000); // Hide status after 2 seconds
          }
        });

        // Listen for updates
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          console.log('üîÑ Service Worker updated, reloading...');
          window.location.reload();
        });
      } else {
        console.warn('‚ö†Ô∏è Service Worker not supported in this browser');
      }
    }

    // Preload ALL media files (videos and images) for instant playback
    async function preloadMediaFiles(){
      // Wait for Service Worker to be ready (crucial for first load)
      if ('serviceWorker' in navigator) {
        try {
          const registration = await navigator.serviceWorker.ready;

          if (!navigator.serviceWorker.controller) {
            console.log('‚è≥ Service Worker not controlling yet, waiting...');
            // On very first load, page needs to be refreshed for SW to take control
            await preloadMediaDirect();
            return;
          }

          // Collect ALL media files (videos and images)
          let allMediaUrls = [];

          // 1. Load videos from medias.json
          try {
            const mediasData = await loadJson(mediasPath);
            if (mediasData && mediasData.medias) {
              const mediaFiles = mediasData.medias
                .filter(m => m.media_type === 'video' || m.media_type === 'image')
                .map(m => m.file_name);
              allMediaUrls.push(...mediaFiles);
              console.log('üì¶ Found', mediaFiles.length, 'video files in medias.json');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not load medias.json:', error);
          }

          // 2. Load images from dining.json
          try {
            const diningData = await loadJson('./client/data/dining.json');
            if (diningData && Array.isArray(diningData)) {
              let diningCount = 0;
              diningData.forEach(rest => {
                if (rest.logo) { allMediaUrls.push(rest.logo); diningCount++; }
                if (rest.images) { allMediaUrls.push(...rest.images); diningCount += rest.images.length; }
              });
              console.log('üì¶ Found', diningCount, 'dining images');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not load dining images:', error);
          }

          // 3. Load images from ondemand.json
          try {
            const ondemandData = await loadJson('./client/data/ondemand.json');
            if (ondemandData && ondemandData.ondemand) {
              let ondemandCount = 0;
              ondemandData.ondemand.forEach(od => {
                if (od.logo) { allMediaUrls.push(od.logo); ondemandCount++; }
                if (od.images) { allMediaUrls.push(...od.images); ondemandCount += od.images.length; }
              });
              console.log('üì¶ Found', ondemandCount, 'ondemand images');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not load ondemand images:', error);
          }

          // 4. Load images from unit.json
          try {
            const unitData = await loadJson('./client/data/unit.json');
            if (unitData && unitData.units) {
              let unitCount = 0;
              unitData.units.forEach(unit => {
                if (unit.images) { allMediaUrls.push(...unit.images); unitCount += unit.images.length; }
                if (unit.floor_plan) { allMediaUrls.push(unit.floor_plan); unitCount++; }
              });
              console.log('üì¶ Found', unitCount, 'unit images');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not load unit images:', error);
          }

          // 5. Load images from project.json
          try {
            const projectData = await loadJson('./project/data/project.json');
            if (projectData && projectData.projects && Array.isArray(projectData.projects)) {
              let projectCount = 0;
              projectData.projects.forEach(proj => {
                if (proj.logo) { allMediaUrls.push(proj.logo); projectCount++; }
                if (proj.images) { allMediaUrls.push(...proj.images); projectCount += proj.images.length; }
              });
              console.log('üì¶ Found', projectCount, 'project images');
            }
          } catch (error) {
            console.warn('‚ö†Ô∏è Could not load project images:', error);
          }

          // 6. Also include sequence media (from playlist)
          if (sequence.length > 0) {
            const sequenceUrls = sequence
              .filter(item => item.kind === 'video' || item.kind === 'image')
              .map(item => item.src);
            allMediaUrls.push(...sequenceUrls);
            console.log('üì¶ Found', sequenceUrls.length, 'playlist media files');
          }

          // Remove duplicates and filter out empty/null values
          allMediaUrls = [...new Set(allMediaUrls.filter(url => url && url.trim()))];

          if (allMediaUrls.length > 0) {
            console.log('üì¶ Requesting preload of', allMediaUrls.length, 'total media files (videos + images) via Service Worker...');

            // Show initial status with total count
            showStatus(`üîç Found ${allMediaUrls.length} media files, preparing to download...`);

            navigator.serviceWorker.controller.postMessage({
              action: 'preloadMedia',
              urls: allMediaUrls
            });
          } else {
            console.warn('‚ö†Ô∏è No media files found to preload');
            showStatus('‚ö†Ô∏è No media files found');
            setTimeout(() => hideStatus(), 3000);
          }
        } catch (error) {
          console.error('‚ùå Service Worker preload failed:', error);
        }
      }
    }

    // Direct preload fallback for first load before Service Worker is controlling
    async function preloadMediaDirect(){
      const mediaUrls = sequence
        .filter(item => item.kind === 'video' || item.kind === 'image')
        .map(item => item.src);

      console.log('üì¶ Direct preloading', mediaUrls.length, 'media files (first visit)...');

      // Fetch files to populate browser cache
      const promises = mediaUrls.slice(0, 3).map(url => // Only preload first 3 on first visit
        fetch(url, { mode: 'no-cors' })
          .then(() => console.log('‚úÖ Preloaded:', url))
          .catch(err => console.warn('‚ö†Ô∏è Failed to preload:', url, err))
      );

      await Promise.all(promises);
    }

    // Auto-update: Detect content changes and clear old cache
    async function checkForContentUpdates(){
      try {
        const currentMediaList = sequence.map(item => item.src).sort().join('|');
        const lastMediaList = localStorage.getItem('cachedMediaList');

        if (lastMediaList && lastMediaList !== currentMediaList) {
          console.log('üîÑ Content changed! Old:', lastMediaList.split('|').length, 'files ‚Üí New:', sequence.length, 'files');
          showStatus('üîÑ Detecting new content, updating cache...');

          // Clear old cache to make room for new content
          if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
            const messageChannel = new MessageChannel();

            messageChannel.port1.onmessage = (event) => {
              if (event.data.success) {
                console.log('‚úÖ Old cache cleared, downloading new content...');
                localStorage.setItem('cachedMediaList', currentMediaList);
                // Reload to download new content
                setTimeout(() => window.location.reload(), 500);
              }
            };

            navigator.serviceWorker.controller.postMessage(
              { action: 'clearCache' },
              [messageChannel.port2]
            );
          } else {
            // No service worker, just update and reload
            localStorage.setItem('cachedMediaList', currentMediaList);
            setTimeout(() => window.location.reload(), 500);
          }
        } else {
          // First time or no changes
          localStorage.setItem('cachedMediaList', currentMediaList);
          console.log('‚úÖ Content list stored:', sequence.length, 'files');
        }
      } catch (error) {
        console.error('‚ùå Update check failed:', error);
      }
    }

    function init(){
      console.log('üöÄ Digital Signage Player (Yodeck Compatible)');
      console.log('‚öôÔ∏è Config loaded:', window.CONFIG ? 'Yes (Inline)' : 'No');
      console.log('üîß To change project: Edit PROJECT_ID in <head> section');

      // Register Service Worker for caching
      registerServiceWorker();

      setupMainCta();
      setupUnlock();
      setupSwipeButton(); // Initialize swipe functionality for ctaHead
      setupSwipeButtonReverse(); // Initialize reverse swipe functionality for ctaMain
      setupVideoNavigation(); // Initialize back/next navigation buttons
      buildSequence().then(({sequence:seq,loop})=>{
        console.log('Built sequence:', seq);
        sequence=seq; loopPlay=loop;

        // Check for content updates and clear old cache if needed
        checkForContentUpdates();

        // Preload media files after sequence is built
        setTimeout(() => preloadMediaFiles(), 1000);

        playAll();
      }).catch(e=>{
        console.error('buildSequence error:', e);
        console.error('Error stack:', e.stack);
        showStatus('‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ' + e.message);
      });
    }

    init();
  })();
  </script>
</body>
</html>
